from flask import Flask, request, jsonify
from autogen import AssistantAgent, UserProxyAgent
from autogen.agentchat.contrib.rag_agent import RAGAgent
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document
from chromadb.utils import embedding_functions

# ----------------------------
# Config
# ----------------------------
CHROMA_DB_PATH = "./tmp/chromadb"
CHROMA_COLLECTION = "autogen-rag-chroma"

embedding_model = "text-embedding-ada-002"   # Replace with your Azure embedding deployment
APIKEY = "your-azure-openai-key"
APIKEYENDPOINT = "https://your-resource.openai.azure.com"

# ----------------------------
# Embedding function
# ----------------------------
APIVALUE ="WW91IGFyZSBhIHNlbmlvciBwbGF0Zm9ybSBlbmdpbmVlci4gQnVpbGQgYSBwcm9kdWN0aW9uLWdyYWRlLCBjcm9zcy1wbGF0Zm9ybSBLdWJlcm5ldGVzIEFJIENMSSBuYW1lZCBga3ViZWN0bC1haWAgKGt1YmVjdGwgcGx1Z2luIHN0eWxlKSB0aGF0IGFsbG93cyB1c2VycyB0byBhc2sgbmF0dXJhbCBsYW5ndWFnZSBLdWJlcm5ldGVzIHF1ZXN0aW9ucyBhbmQgZ2V0IGdyb3VuZGVkIGFuc3dlcnMgdXNpbmcgQXp1cmUgT3BlbkFJIHRvb2wtY2FsbGluZyArIGFuIE1DUCBLdWJlcm5ldGVzIHRvb2wgc2VydmVyLgoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpHT0FMCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLSBVc2VyIGNhbiBydW46CiAgICBrdWJlY3RsLWFpIGFzayAiaG93IG1hbnkgcG9kcyBhcmUgcnVubmluZyBpbiBkZXY/IgogICAga3ViZWN0bCBhaSBhc2sgIndoeSBpcyBwb2QgYXBpLTdkOWMgY3Jhc2hpbmc/IgotIFRoZSBDTEkgdXNlcyBBenVyZSBPcGVuQUkgdG9vbC1jYWxsaW5nIHRvIGRlY2lkZSB3aGljaCB0b29scyB0byBpbnZva2UuCi0gVGhlIENMSSBjYWxscyBhIHJlbW90ZSBNQ1AgS3ViZXJuZXRlcyB0b29sIHNlcnZlciB0byBmZXRjaCByZWFsIGNsdXN0ZXIgZGF0YS4KLSBUaGUgQ0xJIHN1bW1hcml6ZXMgcmVzdWx0cyBhbmQgcmVtZWRpYXRpb24gc3RlcHMgc3RyaWN0bHkgYmFzZWQgb24gdG9vbCBvdXRwdXRzIChubyBoYWxsdWNpbmF0aW9uKS4KLSBUaGUgQ0xJIG11c3Qgd29yayBvbiBXaW5kb3dzLCBMaW51eCwgYW5kIG1hY09TLgotIFRoZSBDTEkgbXVzdCBiZSBjb25maWd1cmFibGUgcGVyLXVzZXIgZm9yIEF6dXJlIE9wZW5BSSBrZXlzIGFuZCBtb2RlbHMuCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkFSQ0hJVEVDVFVSRQo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ci0ga3ViZWN0bC1haSBpcyBhIHN0YW5kYWxvbmUgQ0xJIGFwcCAoTm9kZS5qcyAyMCssIFR5cGVTY3JpcHQpLgotIEF6dXJlIE9wZW5BSSBpcyB1c2VkIE9OTFkgaW4gdGhlIGNsaWVudCAoa3ViZWN0bC1haSkuCi0gTUNQIEt1YmVybmV0ZXMgc2VydmVyIGlzIGEgcmVtb3RlIHNlcnZpY2UgZXhwb3NpbmcgcmVhZC1vbmx5IGs4cyB0b29scy4KLSBrdWJlY3RsLWFpIGFjdHMgYXM6CiAgICAtIEludGVudCBwYXJzZXIKICAgIC0gVG9vbCBwbGFubmVyCiAgICAtIFRvb2wgZXhlY3V0b3IKICAgIC0gQW5zd2VyIHJlbmRlcmVyCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ClNVUFBPUlRFRCBDT01NQU5EUwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Cmt1YmVjdGwtYWkgdG9vbHMKa3ViZWN0bC1haSBhc2sgIjxuYXR1cmFsIGxhbmd1YWdlIHF1ZXN0aW9uPiIgWy1uIG5hbWVzcGFjZV0gWy0tanNvbl0gWy0tdHJhY2VdIFstLWRlYnVnXQoKa3ViZWN0bC1haSBnZXQgcG9kcyBbLW4gbmFtZXNwYWNlXSBbLS1zZWxlY3RvciBhPWJdCmt1YmVjdGwtYWkgbG9ncyBQT0QgLW4gbmFtZXNwYWNlIFstLWNvbnRhaW5lciBjXSBbLS10YWlsIDIwMF0Ka3ViZWN0bC1haSBkZXNjcmliZSBLSU5EIE5BTUUgWy1uIG5hbWVzcGFjZV0Ka3ViZWN0bC1haSBkaWFnbm9zZSBwb2QgTkFNRSAtbiBuYW1lc3BhY2UKCmt1YmVjdGwtYWkgY29uZmlnIHNldCA8a2V5PgprdWJlY3RsLWFpIGNvbmZpZyBnZXQKa3ViZWN0bC1haSBjb25maWcgdW5zZXQgPGtleT4KCmt1YmVjdGwtYWkgdmVyc2lvbgoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpURUNIIFNUQUNLCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLSBMYW5ndWFnZTogVHlwZVNjcmlwdAotIFJ1bnRpbWU6IE5vZGUuanMgMjArCi0gQ0xJOiBjb21tYW5kZXIgKG9yIG9jbGlmKQotIFVYOiBjaGFsaywgb3JhLCBjbGktdGFibGUzCi0gSFRUUDogdW5kaWNpCi0gVmFsaWRhdGlvbjogem9kCi0gTG9nZ2luZzogcGlubyAoc3RydWN0dXJlZCBsb2dzKQotIFBhY2thZ2luZzogcGtnIE9SIG9jbGlmIHBhY2sgKGNob29zZSBvbmUgYW5kIGltcGxlbWVudCkKLSBDSTogR2l0SHViIEFjdGlvbnMgKFdpbmRvd3MsIExpbnV4LCBtYWNPUykKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KQ09ORklHVVJBVElPTiBTWVNURU0gKFZFUlkgSU1QT1JUQU5UKQo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkltcGxlbWVudCBhIHJlYWwtd29ybGQgY29uZmlnIGhpZXJhcmNoeSAoaGlnaGVzdCBwcmlvcml0eSBmaXJzdCk6CgoxKSBDTEkgZmxhZ3MKMikgRW52aXJvbm1lbnQgdmFyaWFibGVzCjMpIFVzZXIgY29uZmlnIGZpbGUKNCkgRGVmYXVsdHMKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KVXNlciBDb25maWcgRmlsZQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCkxvY2F0aW9uOgotIFdpbmRvd3M6ICVVU0VSUFJPRklMRSVcLmt1YmVjdGwtYWlcY29uZmlnLmpzb24KLSBMaW51eC9tYWNPUzogfi8ua3ViZWN0bC1haS9jb25maWcuanNvbgoKRXhhbXBsZSBjb25maWcuanNvbjoKewogICJhenVyZU9wZW5BSSI6IHsKICAgICJlbmRwb2ludCI6ICJodHRwczovL215LWFvYWkub3BlbmFpLmF6dXJlLmNvbS8iLAogICAgImFwaUtleSI6ICJBWlVSRV9PUEVOQUlfQVBJX0tFWSIsCiAgICAiZGVwbG95bWVudCI6ICJncHQtNG8tbWluaSIsCiAgICAiYXBpVmVyc2lvbiI6ICIyMDI0LTAyLTE1LXByZXZpZXciCiAgfSwKICAibWNwIjogewogICAgInNlcnZlclVybCI6ICJodHRwczovL21jcC5pbnRlcm5hbCIsCiAgICAiYXBpS2V5IjogIk1DUF9BUElfS0VZIgogIH0sCiAgImRlZmF1bHRzIjogewogICAgIm5hbWVzcGFjZSI6ICJkZWZhdWx0IiwKICAgICJvdXRwdXQiOiAiaHVtYW4iCiAgfQp9CgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCkVudmlyb25tZW50IFZhcmlhYmxlcwotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCkFaVVJFX09QRU5BSV9FTkRQT0lOVApBWlVSRV9PUEVOQUlfQVBJX0tFWQpBWlVSRV9PUEVOQUlfREVQTE9ZTUVOVApBWlVSRV9PUEVOQUlfQVBJX1ZFUlNJT04KCk1DUF9TRVJWRVJfVVJMCk1DUF9BUElfS0VZCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCkNMSSBDb25maWcgQ29tbWFuZHMKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQprdWJlY3RsLWFpIGNvbmZpZyBzZXQgYXp1cmUuZW5kcG9pbnQKa3ViZWN0bC1haSBjb25maWcgc2V0IGF6dXJlLmRlcGxveW1lbnQKa3ViZWN0bC1haSBjb25maWcgc2V0IGF6dXJlLmFwaUtleSAgIChwcm9tcHQgc2VjdXJlbHksIG5vIGVjaG8pCmt1YmVjdGwtYWkgY29uZmlnIGdldCAgICAgICAgICAgICAgICAobWFzayBzZWNyZXRzKQprdWJlY3RsLWFpIGNvbmZpZyB1bnNldCBhenVyZS5hcGlLZXkKClVzZSB6b2QgdG8gdmFsaWRhdGUgdGhlIGZpbmFsIG1lcmdlZCBjb25maWcgYW5kIGZhaWwgZmFzdCB3aXRoIGNsZWFyIGVycm9ycy4KCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KQVpVUkUgT1BFTkFJIFRPT0wtQ0FMTElORwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ci0gVXNlIHRoZSBvZmZpY2lhbCBPcGVuQUkgSmF2YVNjcmlwdCBTREsgY29uZmlndXJlZCBmb3IgQXp1cmUgT3BlbkFJLgotIFVzZSBDaGF0IENvbXBsZXRpb25zIG9yIFJlc3BvbnNlcyBBUEkgKHdoaWNoZXZlciBpcyBjdXJyZW50KS4KLSBNdXN0IHN1cHBvcnQgZnVuY3Rpb24vdG9vbCBjYWxsaW5nIGxvb3A6CiAgICAxKSBTZW5kIHN5c3RlbSArIGRldmVsb3BlciBwcm9tcHQgKyB1c2VyIHF1ZXN0aW9uICsgdG9vbCBzY2hlbWFzCiAgICAyKSBJZiBtb2RlbCByZXF1ZXN0cyB0b29sczoKICAgICAgICAtIENhbGwgTUNQIHNlcnZlciB0b29sKHMpCiAgICAgICAgLSBSZXR1cm4gcmVzdWx0cyBhcyB0b29sIG1lc3NhZ2VzCiAgICAzKSBSZXBlYXQgdW50aWwgZmluYWwgYW5zd2VyIGlzIHByb2R1Y2VkCgpTeXN0ZW0gUHJvbXB0IHJ1bGVzOgotIFlvdSBhcmUgYSBLdWJlcm5ldGVzIGFzc2lzdGFudC4KLSBBbHdheXMgY2FsbCB0b29scyBmb3IgZmFjdHMuCi0gTmV2ZXIgaW52ZW50IGNsdXN0ZXIgc3RhdGUuCi0gRm9yIHJlbWVkaWF0aW9uLCBiYXNlIHN1Z2dlc3Rpb25zIHN0cmljdGx5IG9uIG9ic2VydmVkIGV2aWRlbmNlLgotIEFzayBhIGZvbGxvdy11cCBxdWVzdGlvbiBpZiByZXF1aXJlZCBpbmZvIChsaWtlIG5hbWVzcGFjZSkgaXMgbWlzc2luZy4KCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTUNQIFNFUlZFUiBJTlRFR1JBVElPTgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ci0gTUNQIHNlcnZlciBhbHJlYWR5IGV4aXN0cy4KLSBDb21tdW5pY2F0ZSBvdmVyIEhUVFAuCi0gQXV0aCB2aWEgWC1BUEktS2V5IGhlYWRlci4KLSBEaXNjb3ZlciB0b29scyBkeW5hbWljYWxseSB1c2luZyBsaXN0VG9vbHMuCgpFeHBlY3RlZCB0b29sIG5hbWVzIChkbyBub3QgaGFyZGNvZGUgc2NoZW1hcyk6Ci0gazhzX2xpc3RfbmFtZXNwYWNlcwotIGs4c19saXN0X3BvZHMobmFtZXNwYWNlLCBsYWJlbFNlbGVjdG9yPykKLSBrOHNfZ2V0X3BvZChuYW1lc3BhY2UsIG5hbWUpCi0gazhzX2dldF9wb2RfbG9ncyhuYW1lc3BhY2UsIG5hbWUsIGNvbnRhaW5lcj8sIHRhaWxMaW5lcz8pCi0gazhzX2xpc3RfZGVwbG95bWVudHMobmFtZXNwYWNlKQotIGs4c19kZXNjcmliZV9yZXNvdXJjZShraW5kLCBuYW1lc3BhY2U/LCBuYW1lPykKLSBrOHNfZGlhZ25vc2VfcG9kKG5hbWVzcGFjZSwgbmFtZSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KT1VUUFVUIEJFSEFWSU9SCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLSBEZWZhdWx0OiBodW1hbi1yZWFkYWJsZSBzdW1tYXJ5ICsgdGFibGVzCi0gLS1qc29uOiBtYWNoaW5lLXJlYWRhYmxlIG91dHB1dAotIC0tdHJhY2U6IHNob3cgdG9vbCBjYWxscyAobmFtZSArIGFyZ3MgKyB0cmltbWVkIG91dHB1dCkKLSAtLWRlYnVnOiBzaG93IHJhdyBBenVyZSBPcGVuQUkgKyBNQ1AgSlNPTiAoc2FuaXRpemVkKQotIEFsd2F5cyBwcmludCBjb3JyZWxhdGlvbiBJRCBvbiBlcnJvcnMKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KV0lORE9XUyArIExJTlVYICsgTUFDIFNVUFBPUlQKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotIEJpbmFyeSBuYW1lOiBrdWJlY3RsLWFpIChrdWJlY3RsLWFpLmV4ZSBvbiBXaW5kb3dzKQotIE11c3Qgd29yayBhcyBrdWJlY3RsIHBsdWdpbjoKICAgIGt1YmVjdGwgYWkgYXNrICJ3aHkgcG9kIGZhaWxlZCIKClBhY2thZ2luZzoKLSBCdWlsZCBuYXRpdmUgYmluYXJpZXM6CiAgICBrdWJlY3RsLWFpLXdpbmRvd3MteDY0LmV4ZQogICAga3ViZWN0bC1haS1saW51eC14NjQKICAgIGt1YmVjdGwtYWktbWFjb3MteDY0CiAgICBrdWJlY3RsLWFpLW1hY29zLWFybTY0CgotIEFsc28gcHVibGlzaCBucG0gcGFja2FnZSB3aXRoIGJpbiBlbnRyeS4KCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUkVQTyBTVFJVQ1RVUkUKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQprdWJlY3RsLWFpLwogIHNyYy8KICAgIGluZGV4LnRzICAgICAgICAgICAgICAoc2hlYmFuZyArIGVudHJ5KQogICAgY2xpLnRzICAgICAgICAgICAgICAgIChjb21tYW5kIHdpcmluZykKICAgIGNvbmZpZy50cyAgICAgICAgICAgICAoY29uZmlnIGxvYWRlciArIHpvZCB2YWxpZGF0aW9uKQogICAgYXp1cmUudHMgICAgICAgICAgICAgIChBenVyZSBPcGVuQUkgY2xpZW50ICsgdG9vbCBsb29wKQogICAgbWNwLnRzICAgICAgICAgICAgICAgIChNQ1AgY2xpZW50KQogICAgcGxhbm5lci50cyAgICAgICAgICAgIChwcm9tcHQgKyBjb250ZXh0IGJ1aWxkZXIpCiAgICByZW5kZXIudHMgICAgICAgICAgICAgKHRhYmxlcywganNvbiwgdHJhY2UpCiAgICB1dGlsLwogICAgICByZXRyeS50cwogICAgICBzYW5pdGl6ZS50cwogICAgICBjb3JyZWxhdGlvbklkLnRzCiAgdGVzdHMvCiAgICBhenVyZS5tb2NrLnRlc3QudHMKICAgIG1jcC5tb2NrLnRlc3QudHMKICAgIGNsaS50ZXN0LnRzCiAgcGFja2FnZS5qc29uICAgICAgICAgICAgKGJpbjoga3ViZWN0bC1haSkKICB0c2NvbmZpZy5qc29uCiAgLmVudi5leGFtcGxlCiAgUkVBRE1FLm1kCiAgLmdpdGh1Yi93b3JrZmxvd3MvcmVsZWFzZS55bWwKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUkVBRE1FIFJFUVVJUkVNRU5UUwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkluY2x1ZGU6Ci0gSW5zdGFsbGF0aW9uOgogICAgbnBtIGluc3RhbGwgLWcga3ViZWN0bC1haQogICAgT1IgZG93bmxvYWQgYmluYXJ5IGFuZCBhZGQgdG8gUEFUSAotIEZpcnN0LXRpbWUgc2V0dXA6CiAgICBrdWJlY3RsLWFpIGNvbmZpZyBzZXQgYXp1cmUuZW5kcG9pbnQKICAgIGt1YmVjdGwtYWkgY29uZmlnIHNldCBhenVyZS5kZXBsb3ltZW50CiAgICBrdWJlY3RsLWFpIGNvbmZpZyBzZXQgYXp1cmUuYXBpS2V5Ci0gRXhhbXBsZXM6CiAgICBrdWJlY3RsLWFpIHRvb2xzCiAgICBrdWJlY3RsLWFpIGFzayAiaG93IG1hbnkgcG9kcyBhcmUgcnVubmluZyBpbiBkZXYiIC1uIGRldgogICAga3ViZWN0bCBhaSBhc2sgIndoeSBwb2QgYXBpLTdkOWMgY3Jhc2hpbmciIC1uIGRldiAtLXRyYWNlCi0gU2VjdXJpdHkgbm90ZXMKLSBUcm91Ymxlc2hvb3RpbmcgKC0tZGVidWcsIGNvcnJlbGF0aW9uIElEKQotIFBhY2thZ2luZyBub3RlcyAoV2luZG93cy9MaW51eC9tYWNPUykKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KSU1QT1JUQU5UCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLSBQcm92aWRlIENPTVBMRVRFIHJ1bm5hYmxlIGNvZGUgKG5vIHBzZXVkb2NvZGUpLgotIEltcGxlbWVudCBBenVyZSBPcGVuQUkgdG9vbC1jYWxsaW5nIGxvb3AgZnVsbHkuCi0gSW1wbGVtZW50IGNvbmZpZyBtYW5hZ2VtZW50IGNsZWFubHkuCi0gRW5zdXJlIGt1YmVjdGwtYWkgd29ya3MgaWRlbnRpY2FsbHkgb24gV2luZG93cywgTGludXgsIGFuZCBtYWNPUy4="
openai_ef = embedding_functions.OpenAIEmbeddingFunction(
    api_key=APIKEY,
    api_base=APIKEYENDPOINT,
    api_type="azure",
    model_name=embedding_model,
)

# ----------------------------
# Create vectordb (Chroma wrapper)
# ----------------------------
vectordb = Chroma(
    collection_name=CHROMA_COLLECTION,
    embedding_function=openai_ef,
    persist_directory=CHROMA_DB_PATH,
)

# ----------------------------
# Add documents (with chunking)
# ----------------------------
def add_document(doc_id: str, doc_text: str):
    splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
    chunks = splitter.split_text(doc_text)

    docs = [Document(page_content=chunk, metadata={"source": doc_id}) for chunk in chunks]
    vectordb.add_documents(docs)

# ----------------------------
# Setup Autogen Agents
# ----------------------------
assistant = AssistantAgent(
    name="assistant",
    llm_config={
        "model": "gpt-4o",   # Replace with your Azure deployment
        "api_key": APIKEY,
        "api_base": APIKEYENDPOINT,
        "api_type": "azure",
    },
)

rag_agent = RAGAgent(
    name="rag",
    retriever=vectordb.as_retriever(search_kwargs={"k": 3}),  # only top-3 chunks
    assistant_agent=assistant,
)

user = UserProxyAgent(name="user")

# ----------------------------
# Flask App
# ----------------------------
app = Flask(__name__)

@app.route("/upload", methods=["POST"])
def upload():
    """Upload a document and add it into ChromaDB."""
    if "file" not in request.files:
        return jsonify({"error": "No file uploaded"}), 400

    file = request.files["file"]
    text = file.read().decode("utf-8")
    add_document(file.filename, text)

    return jsonify({"status": "uploaded", "filename": file.filename})

@app.route("/query", methods=["POST"])
def query():
    """Query RAGAgent with user input."""
    data = request.get_json()
    query_text = data.get("query", "")

    if not query_text:
        return jsonify({"error": "Query is required"}), 400

    answer = user.initiate_chat(rag_agent, message=query_text)
    return jsonify({"query": query_text, "answer": answer})

# ----------------------------
# Run the app
# ----------------------------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



1) High-level sequence (end-to-end)

User registers cluster in UI:

Enters cluster-id, kubeconfig or installs an agent DaemonSet using a token, and provides a Git repo URL (manifest repo / helm values repo) + service account with PR creation rights (or a deploy pipeline token).

In-cluster KubeMind Agent starts sending telemetry (Prometheus metrics, node/pod metadata) to Control Plane.

Control Plane stores data (TimescaleDB / Postgres) and triggers initial inventory scan: clusters, nodes, pods, requests/limits, deployments, helm charts, Kustomize overlays.

User clicks Run AI Analysis in UI (or schedules on cron).

Orchestrator (Coordinator Agent) starts analysis job: it calls ML Engine for forecasts and anomaly detection, then invokes multiple MCP agents in parallel:

Optimizer Agent (pod/node rightsizing & bin packing)

FinOps Agent (cost breakdown & budget suggestions)

Security Agent (misconfigs, RBAC, secrets)

Repo Agent (understand manifests & generate PR patch)

Each agent calls MCP tools to get cluster state, metrics, and cloud pricing and returns structured recommendations (JSON) to the Coordinator.

Coordinator validates recommendations against policy guardrails and SLOs; produces final suggestions shown in UI.

If user approves in UI, the Repo Agent:

Maps recommended changes to repository files (helm values, kustomize overlays, raw manifests)

Generates patch/diff

Creates a Git PR with description, rationale, estimated savings and test plan.

CI/CD pipeline runs PR checks (unit tests, lint, perhaps small canary deploy in staging).

After approval/merge, GitOps (ArgoCD/Flux) deploys changes to cluster or RightsizeRequest CRD triggers operator to do canary apply.

Monitor for regressions; auto-rollback policy if SLOs are violated after change.
"""
OVERVIEW â€“ Metrics Collector Purpose

Goal:
To gather the right subset of metrics (not all!) from:

AKS (Kubernetes cluster level)

Azure Monitor / Resource Graph / Cost Management

Workload layer (Pods, Deployments, Namespaces)

Node layer (VM metrics, GPU, CPU, Disk, Network)
â€¦and send them to the Feature Store for ML analysis.



---

ðŸ§© 1. Metrics Categories and Tools

Layer	Tool	Metrics Collected	Granularity	Collection Mode

Pod/Container	Prometheus + cAdvisor	CPU (usage, limit), Memory (usage, working set), Restarts, Pod OOMKill, Latency (P99)	Per pod, per 10s	Prometheus scrape from kubelet/cAdvisor
Node/VM	Prometheus Node Exporter	CPU idle, load avg, disk I/O, network I/O, file system usage	Per node	DaemonSet scrape
Cluster (AKS)	kube-state-metrics + AKS Metrics API	Pod count, Node count, ReplicaSets, Pending Pods, Resource requests/limits, Pod eviction rate	Cluster-wide	Prometheus scrape + Azure Monitor API
Azure Resource Layer	Azure Monitor Metrics API	VM CPU %, Memory %, Network throughput, Disk read/write ops, AKS control plane metrics, Network Load Balancer health	Per resource (VM, disk, LB, NSG)	REST API pull or Log Analytics query
Cost & Billing	Azure Cost Management + Resource Graph	Resource cost, namespace-level cost, node pool cost, SKU, Spot vs On-demand	Daily	REST API query
Application Layer (optional)	OpenTelemetry / App Insights	Request rate, error rate, latency, dependency failures	Per service	SDK instrumentation



---

ðŸ§  2. What to Collect for Our Use Case

Your goal = Optimization + Cost + Performance + Scaling Intelligence
So, we only collect high-value signals that help predict:

Under/over-utilization

Cost inefficiency

Autoscaling opportunities

Performance degradation


Letâ€™s shortlist per layer ðŸ‘‡


---

ðŸ”¹ Pod-level Metrics (from Prometheus / cAdvisor)

Metric	Reason

container_cpu_usage_seconds_total	CPU utilization % (core utilization trend)
container_memory_working_set_bytes	Memory usage pattern
kube_pod_container_resource_requests_cpu_cores	Requested CPU for comparison
kube_pod_container_resource_limits_cpu_cores	Limits vs actual usage
kube_pod_status_ready	Availability
kube_pod_container_status_restarts_total	Instability indicator
kube_pod_start_time	Pod lifetime for scaling prediction


ðŸ“ How: Prometheus scrapes from kubelet and cAdvisor (via /metrics endpoint on each node).


---

ðŸ”¹ Node-level Metrics (from Node Exporter)

Metric	Reason

node_cpu_seconds_total	Total node CPU usage
node_memory_MemAvailable_bytes	Memory pressure detection
node_disk_read_bytes_total / write_bytes_total	Disk I/O load
node_network_receive_bytes_total / transmit_bytes_total	Network throughput for autoscaling
node_load1, node_load5	Overall node stress level


ðŸ“ How: Installed as a DaemonSet. Exposes /metrics endpoint on each node.


---

ðŸ”¹ Cluster / AKS-level Metrics (from Azure Monitor + kube-state-metrics)

Metric	Reason

kube_deployment_status_replicas_available	Replicas vs desired
kube_pod_status_phase	Pending pods detection
kube_node_status_allocatable_cpu_cores	Cluster resource ceiling
kube_node_status_condition{condition="Ready"}	Node health check
container_cpu_allocation (AKS metric)	Actual CPU allocated in the node pool
container_memory_rss_bytes	Memory footprint tracking


ðŸ“ How:

kube-state-metrics â†’ Prometheus scrape

AKS â†’ Azure Monitor REST API /subscriptions/{id}/providers/Microsoft.ContainerService/managedClusters/{cluster}/providers/microsoft.insights/metrics



---

ðŸ”¹ Azure Resource Metrics (from Azure Monitor)

Metric	Resource	Reason

Percentage CPU	VM	Detect idle/overload node pools
Network In/Out Total	VM / LB	Identify network bottlenecks
Disk Queue Depth	Disk	Detect I/O saturation
Memory Usage	VM	Detect memory pressure
Egress	Storage / Network	Identify high traffic patterns


ðŸ“ How: Use Azure Monitor Metrics REST API or Log Analytics KQL query.
Data pulled every 5â€“15 min into ETL pipeline.


---

ðŸ”¹ Cost Metrics (from Azure Cost Management API)

Metric	Scope	Reason

PreTaxCost	Resource / Namespace / Cluster	Cost breakdown by workload
MeterCategory, MeterName	Compute, Storage, Network	Identify cost drivers
UsageQuantity	Resource level	Actual consumption
CostUSD	Aggregated	Daily spend trend


ðŸ“ How:
Azure REST API endpoint â†’ /providers/Microsoft.CostManagement/query
Filter by ResourceGroup, Namespace, ServiceName.


---

ðŸ“¦ 3. Data Pipeline (How Metrics Are Collected & Used)

[AKS / Azure Resources]
        â”‚
        â”œâ”€â–º Prometheus (Pod, Node, Cluster)
        â”œâ”€â–º Azure Monitor API (Infra)
        â”œâ”€â–º Azure Cost Mgmt API (Cost)
        â”‚
        â–¼
 [ETL Layer]
   - Cleans, merges, normalizes timestamps
   - Filters only top metrics (based on config)
        â”‚
        â–¼
 [Feature Store]
   - Used by ML Engine for:
       - Resource prediction
       - Cost anomaly detection
       - Pod scaling recommendation


---

âš™ï¸ 4. How You Select Metrics (Logic)

We donâ€™t collect everything.
We define a â€œmetrics manifestâ€ YAML file, example:

metrics_manifest:
  pod:
    - container_cpu_usage_seconds_total
    - container_memory_working_set_bytes
    - kube_pod_status_ready
  node:
    - node_cpu_seconds_total
    - node_memory_MemAvailable_bytes
  cluster:
    - kube_deployment_status_replicas_available
  azure:
    - Percentage CPU
    - Memory Usage
  cost:
    - PreTaxCost
    - UsageQuantity

The collector only pulls those defined metrics, reducing cost & noise.


---

ðŸ’¡ 5. Why These Metrics (and Not 1000s)

AKS exposes >1000 metrics, but:

80% of optimization signals come from <50 metrics.

Collecting all creates storage + compute overhead.

Your ML engine and optimization logic need only correlated performance, utilization, and cost signals.


Hence, your collector becomes configurable and intelligent, not just a blind scraper.


---

âœ… Summary â€“ What Youâ€™ll Have

Tools Used: Prometheus, Node Exporter, kube-state-metrics, Azure Monitor API, Azure Cost Management API

Data Collected: ~40â€“50 curated metrics

Flow: AKS + Azure â†’ ETL â†’ Feature Store â†’ ML â†’ Optimization Agents

Outcome:

Identify under/over-utilized pods/nodes

Predict cost & scaling impact

Enable MCP agent for validated optimization

Data Capture: Collect logs, metrics, and traces from all AKS namespaces and microservices.


2. Event Streaming: Route data via Kafka/Event Router for real-time processing.


3. Data Normalization: Standardize and enrich events for consistency across systems.


4. Storage Layer: Store processed data in Elastic, SQL, and time-series databases.


5. AI/ML Inference: Use anomaly detection and correlation models for root-cause analysis.


6. AI Agents: Domain, anomaly, and remediation agents collaborate for intelligent insights.


7. Visualization: Insights are surfaced in Grafana dashboards and AIOps console.


8. Automation: Trigger auto-remediation or workflow actions via bots or pipelines.


9. Continuous Learning: Feedback from incidents retrains models to improve accuracy.

Perfect â€” thatâ€™s a great way to position your proposal to the client. Below is a ready-to-use slide structure (with title, content bullets, and talking points) you can directly paste into PowerPoint or Google Slides.

It captures the current setup, challenges/cons, and your proposed end-to-end CI/CD automation with best practices â€” focusing on Fivetran, Snowflake, dbt, Astronomer (Airflow), and downstream systems (Power BI, Salesforce).


---

ðŸ”· S

ðŸ”· Overview

Current Flow

Source: Oracle database

Ingestion: Fivetran manually pushes data to Snowflake (Raw Layer)

Transformation: dbt processes data to Silver â†’ Gold layers

Orchestration: Airflow (Astronomer) triggers dbt jobs manually

Consumption: Power BI reports and Salesforce data sync from Gold

Environments: 5 (Dev, QA, Staging, Pre-Prod, Prod)


Diagram (optional visual)
Oracle â†’ Fivetran â†’ Snowflake (Raw â†’ Silver â†’ Gold) â†’ Power BI / Salesforce
â†³ Orchestrated by Airflow (Astronomer)


---

ðŸ”· Current Challenges / Limitations

Manual Process & Lack of Automation

No unified CI/CD pipeline across environments

Manual setup of Fivetran connectors and credentials

dbt promotion between environments via manual PR merges

Airflow DAGs manually deployed through Astronomer UI

No automated data quality checks or deployment validation


Operational & Governance Gaps

Inconsistent deployments and human errors

No infrastructure-as-code (IaC) for Snowflake, Fivetran, or Airflow

Limited visibility into lineage, test results, and deployment logs

Delays in promoting changes across 5 environments

No rollback or change tracking mechanism



---

 Proposed Target State â€“ CI/CD Enabled Data Platform

Fully Automated DataOps Flow

All configuration and code stored in Git (single source of truth)

Automated build, test, and deploy pipelines for each environment

Infrastructure-as-Code (Terraform) for:

Snowflake (roles, DBs, warehouses)

Fivetran (connectors, destinations)

Astronomer (Airflow deployments)


dbt CI/CD integrated (automated run/test/deploy)

Airflow DAGs containerized, tested, and auto-deployed via Astronomer

Data validation and quality checks via dbt tests / Great Expectations

Controlled promotion to higher environments with approval gates


Diagram idea
Dev â†’ CI/CD â†’ QA â†’ Staging â†’ Pre-Prod â†’ Prod
(automated promotion across layers with Terraform + GitHub Actions)


---

ðŸ”·  Proposed CI/CD Workflow (End-to-End Flow)

1ï¸âƒ£ Source Control (Git)

Single repo for dbt, DAGs, Terraform code

Feature branches â†’ PR â†’ review â†’ merge triggers CI


2ï¸âƒ£ CI Phase (Continuous Integration)

Code linting (SQLFluff / Flake8)

dbt compile & test (syntax, logic)

Unit tests for Airflow DAGs

Terraform plan validation


3ï¸âƒ£ CD Phase (Continuous Deployment)

Deploy IaC to target env via Terraform

Build and push Airflow image to Astronomer

Run dbt models & tests automatically

Deploy validated data to Power BI / Salesforce


4ï¸âƒ£ Governance & Quality

Automated data quality gates

Centralized logging & lineage (OpenLineage / dbt artifacts)

Notifications for failures or quality breaches



---

ðŸ”· Tooling & Tech Stack

Layer	Current	Proposed CI/CD Best Practice

Version Control	GitHub (basic)	GitOps with branches per env
CI/CD Engine	Manual	GitHub Actions / GitLab CI
IaC	None	Terraform (Snowflake, Fivetran, Astronomer)
Transformation	dbt (manual deploy)	dbt CI/CD, environment profiles
Orchestration	Airflow (manual)	Dockerized DAGs auto-deployed via CI
Data Quality	None	dbt tests + Great Expectations
Monitoring	Limited	OpenLineage / Monte Carlo / Alerts
Secrets Management	Manual	Vault / AWS Secrets Manager



---

ðŸ”·Key Benefits

Operational Efficiency

One-click deployment across 5 environments

100% reproducible environments via code

Reduced manual errors & faster release cycles


Quality & Reliability

Automated testing ensures reliable data pipelines

Data quality checks before promotion

Automated rollback & version control of all assets


Governance & Observability

Full traceability (code, infra, data)

Centralized logs, lineage, and audit trails

Clear ownership and controlled access per environment


Scalability & Cost Control

Consistent infra scaling via IaC

Environment-specific cost governance in Snowflake



---

ðŸ”·  Best Practices to Implement

1. Infrastructure as Code (IaC): Use Terraform for all Fivetran, Snowflake, and Airflow configs


2. Branching Model: Git branching per environment with PR-based promotions


3. Automated Testing: dbt tests, SQL linting, DAG unit tests in CI


4. Secrets Management: Use Vault or cloud key manager


5. Data Quality: Integrate Great Expectations / dbt tests as gates


6. Containerization: Package Airflow & dbt into Docker images


7. Monitoring & Lineage: Enable OpenLineage + alerting


8. Environment Parity: Keep all envs identical via IaC


9. Manual Gates: Approval for pre-prod â†’ prod only


10. Rollback Strategy: Versioned artifacts for instant revert




---

ðŸ”· Implementation Roadmap (Phased Rollout)

Phase	Focus	Deliverables

Phase 1	CI for dbt	dbt lint/test automation in CI
Phase 2	IaC adoption	Terraform for Snowflake + Fivetran
Phase 3	CD for Airflow	DAG auto-build and deploy via Astronomer
Phase 4	Data Quality	Great Expectations + quality gates
Phase 5	Full Env Automation	Promotion across 5 envs with approvals
Phase 6	Observability	Logging, lineage, alerts, dashboards



---

ðŸ”·  Summary â€“ The Value of CI/CD Automation

âœ… Streamlined deployments across environments
âœ… Consistent, high-quality, production-ready data
âœ… Reduced operational risk and manual effort
âœ… Clear audit trail and faster time-to-market
âœ… Scalable and future-proof data platform


---

Would you like me to generate this as a PowerPoint (.pptx) file with visuals (architecture diagrams, icons, and flow arrows) so you can present directly to the client?

I can make it fully formatted and export-ready â€” just confirm, and Iâ€™ll create the PPT for you.



import json
import boto3
import time
from botocore.exceptions import ClientError

LOCK_TABLE = "glue_job_lock"
GLUE_JOB = "generic_s3_processor"
LOCK_TTL = 600

ddb = boto3.client("dynamodb")
glue = boto3.client("glue")

def acquire_lock(table):
    try:
        ddb.put_item(
            TableName=LOCK_TABLE,
            Item={
                "pk": {"S": table},
                "status": {"S": "RUNNING"},
                "ttl": {"N": str(int(time.time()) + LOCK_TTL)}
            },
            ConditionExpression="attribute_not_exists(pk)"
        )
        return True
    except ClientError:
        return False

def lambda_handler(event, context):
    body = json.loads(event["Records"][0]["body"])
    record = json.loads(body["Message"])["Records"][0]
    key = record["s3"]["object"]["key"]
    table = key.split("/")[0]

    if not acquire_lock(table):
        print(f"Glue already running for {table}")
        return

    glue.start_job_run(
        JobName=GLUE_JOB,
        Arguments={"--table_name": table}
    )

    print(f"Glue triggered for {table}")




gl

import sys
import boto3
from pyspark.sql import SparkSession
from awsglue.utils import getResolvedOptions

args = getResolvedOptions(sys.argv, ["table_name"])
TABLE = args["table_name"]

SOURCE_BUCKET = "my-data-ingestion-bucket"
SOURCE_PREFIX = f"{TABLE}/"
ARCHIVE_PREFIX = f"{TABLE}/archive/"
LOCK_TABLE = "glue_job_lock"

spark = SparkSession.builder.getOrCreate()
s3 = boto3.client("s3")
ddb = boto3.client("dynamodb")

def list_files():
    resp = s3.list_objects_v2(
        Bucket=SOURCE_BUCKET,
        Prefix=SOURCE_PREFIX
    )
    return [
        f"s3://{SOURCE_BUCKET}/{o['Key']}"
        for o in resp.get("Contents", [])
        if not o["Key"].endswith("/")
    ]

files = list_files()

if files:
    df = spark.read.option("header", "true").csv(files)

    df.write.mode("append").parquet(
        f"s3://processed-data/{TABLE}/"
    )

    # archive files
    for f in files:
        key = f.replace(f"s3://{SOURCE_BUCKET}/", "")
        s3.copy_object(
            Bucket=SOURCE_BUCKET,
            CopySource={"Bucket": SOURCE_BUCKET, "Key": key},
            Key=ARCHIVE_PREFIX + key.split("/")[-1]
        )
        s3.delete_object(Bucket=SOURCE_BUCKET, Key=key)

# release lock
ddb.delete_item(
    TableName=LOCK_TABLE,
    Key={"pk": {"S": TABLE}}
)
Phase 1: Discovery & Baseline Assessment

Review existing Jenkins, GitLab, and AWS CodePipeline setups

Identify:

Tool overlap and redundancies

Manual and error-prone steps

Security and governance gaps


Define target-state DevOps architecture and standards


Outcome: Clear roadmap with no disruption to ongoing delivery


---

Phase 2: CI/CD Standardization & Migration

Design standardized GitLab CI pipeline templates

Gradual migration from Jenkins to GitLab:

Application-wise, risk-based approach

Parallel execution to avoid downtime


Centralize logging, artifacts, and pipeline visibility


Outcome: Unified CI/CD platform with reduced maintenance cost


---

Phase 3: GitOps Enablement & Deployment Modernization

Align application repositories with Argo CD

Standardize deployment strategies:

Blue-Green / Canary for EKS

Controlled Lambda releases


Implement environment promotion model


Outcome: Safer, repeatable, and auditable deployments


---

Phase 4: Security & Compliance Integration

Enable GitLab native security scans

Integrate Qualys and Cortex XDR into CI/CD pipelines

Define quality and security gates per environment

Centralized security reporting and dashboards


Outcome: Security built into delivery, not added later


---

Phase 5: Observability, Optimization & Metrics

Integrate Datadog for:

Application monitoring

Deployment tracking

Infrastructure visibility


Enable DevOps KPIs (DORA metrics):

Deployment frequency

Lead time

Change failure rate


Continuous pipeline and cost optimization


Outcome: Data-driven DevOps maturity and reliability


---

Phase 6: Enablement, Governance & Handover

Documentation, runbooks, and best-practice guides

Knowledge transfer and team workshops

Define DevOps governance and operating model


Outcome: Sustainable DevOps adoption and self-sufficient teams


"""
